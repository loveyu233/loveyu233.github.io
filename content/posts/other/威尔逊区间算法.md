---
title: "威尔逊区间算法"
date: 2025-07-08T10:25:21+08:00
author: ["loveyu"]
draft: false
categories: 
- other
tags: 
- wilson
---

#### 1. **背景与用途**

威尔逊区间（Wilson Score Interval）是统计学中用于估计**二项分布比例**的置信区间，适用于样本量较小或比例接近0/1的情况。与传统的正态近似区间（如Wald区间）相比，它在极端比例或小样本时更稳定，避免“0%或100%”的不合理区间。

#### 2. **公式推导**

- **核心思想**：结合样本比例和正态分布的分位数，调整置信区间的边界。

- **公式**：

  (p^+z22n1+z2n±z⋅p^(1−p^)n+z24n2)/(1+z2n)(1+*n**z*2*p*^+2*n**z*2±*z*⋅*n**p*^(1−*p*^)+4*n*2*z*2)/(1+*n**z*2)

  其中：

  - p^*p*^：样本中的成功比例（如好评率）。
  - n*n*：样本量。
  - z*z*：标准正态分布的分位数（如95%置信度对应z=1.96*z*=1.96）。

#### 3. **简化版本**

常用简化形式：

(p^+z22n1+z2n±z1+z2np^(1−p^)n+z24n2)(1+*n**z*2*p*^+2*n**z*2±1+*n**z*2*z**n**p*^(1−*p*^)+4*n*2*z*2)

#### 4. **为何优于Wald区间？**

- **Wald区间问题**：当p^=0*p*^=0或11时，区间宽度为0（不合理）；小样本时覆盖概率低。
- **威尔逊调整**：通过引入z2/n*z*2/*n*项，避免极端情况下的边界坍塌，更接近真实置信水平。

#### 5. **应用场景**

- **小样本比例估计**：如调查中仅有几十个样本。
- **极端比例**：如好评率99%或1%。
- **排序算法**：如Reddit、亚马逊的评分排序（结合区间下限）。

#### 6. **示例计算**

假设某产品10个评价中有9个好评（p^=0.9,n=10*p*^=0.9,*n*=10），95%置信度（z=1.96*z*=1.96）：

威尔逊区间≈0.9±1.960.9×0.110+1.962400/(1+0.384)≈(0.61,0.98)威尔逊区间≈0.9±1.96100.9×0.1+4001.962/(1+0.384)≈(0.61,0.98)

对比Wald区间（0.9±0.190.9±0.19即(0.71,1.09)(0.71,1.09)，上限超1不合理）。

#### 7. **数学性质**

- **一致性**：当n→∞*n*→∞时，威尔逊区间收敛到真实比例。
- **保序性**：适用于基于区间边界的排序（如“保守估计”取下界）。

#### 8. **与其他方法的对比**

- **Clopper-Pearson区间**：精确但保守，计算复杂。
- **Jeffreys区间**：基于贝叶斯方法，适用于无先验信息时。

#### 9. **实际注意事项**

- **样本量**：即使n*n*很小，威尔逊区间仍可用，但宽度较大。
- **连续性校正**：对离散数据可进一步调整，但公式更复杂。

假设你正在设计一个“热评系统”，比如：

- **B站**的视频评论排序
- **知乎**的回答排名
- **电商网站**的商品评价排序

你希望把“质量高”的内容排到前面，但面临一个问题：

### 简单按“好评率”排序会出问题

- **新评论**：比如一个新评论，只有 **1人点赞，0人点踩**（好评率100%），如果直接按好评率排，它会超过 **1000人点赞，100人点踩**（好评率90%）的老评论，这显然不合理。
- **极端情况**：0人投票的内容，好评率是0%还是100%？无法判断。

### 威尔逊区间的核心思想

这个算法的聪明之处在于：**它不仅仅看“好评率”，还会考虑“有多少人投票”**。

- **投票越多，结果越可信**（比如1000人投90%好评，比10人投100%好评更可靠）。
- **投票越少，算法越保守**（比如只有1人投票，即使100%好评，系统也不会完全信任）。

### 类比现实生活

想象你在选一家餐厅：

- **A餐厅**：2个人评价，都是5星（好评率100%）
- **B餐厅**：200人评价，平均4.8星（好评率96%）

你会更信任**B餐厅**，因为样本量大，结果更稳定。威尔逊区间就是帮你做这个判断的数学工具。

### 算法输出（威尔逊得分）

- 对于 **1000点赞 + 100点踩**，算法会计算一个较高的分数（比如 **0.85**）。
- 对于 **1点赞 + 0点踩**，算法会计算一个较低的分数（比如 **0.60**），即使它的好评率是100%。

```go
package main

import (
	"fmt"
	"math"
)

// WilsonScoreInterval 计算威尔逊区间的下限（用于排序）
// upVotes: 赞同数
// totalVotes: 总票数（赞同+反对）
// confidence: 置信水平（默认1.96对应95%置信度）
// 置信度	Z 值	适用场景
// 90%		1.645	一般推荐系统（稍微宽松）
// 95%		1.96	最常用（平衡准确和保守）
// 99%		2.576	高严格度（如金融、医学）
func WilsonScoreInterval(upVotes, totalVotes int, confidence float64) float64 {
	if totalVotes == 0 {
		return 0
	}

	// 计算好评率
	pHat := float64(upVotes) / float64(totalVotes)

	// 威尔逊区间公式（简化版）
	z := confidence
	n := float64(totalVotes)
	
	// 核心计算
	center := (pHat + z*z/(2*n)) / (1 + z*z/n)
	margin := z * math.Sqrt((pHat*(1-pHat)+z*z/(4*n)) / n / (1 + z*z/n)

	// 返回区间下限（更保守的估计，适合排序）
	return center - margin
}

func main() {
	// 示例1：Reddit风格热评（95%置信度）
	up := 100
	down := 10
	score := WilsonScoreInterval(up, up+down, 1.96)
	fmt.Printf("好评数%d, 总票数%d -> 威尔逊得分: %.4f\n", up, up+down, score)

	// 示例2：小样本测试（9好评1差评）
	smallScore := WilsonScoreInterval(9, 10, 1.96)
	fmt.Printf("小样本测试(9/10) -> 得分: %.4f\n", smallScore)

	// 示例3：极端情况（0票）
	zeroScore := WilsonScoreInterval(0, 0, 1.96)
	fmt.Printf("无投票时 -> 得分: %.4f\n", zeroScore)
}
```

