---
title: "面试指南"
date: 2023-02-17T22:50:21+08:00
author: ["loveyu"]
draft: false
categories: 
- go
tags: 
- go
- redis
- mysql
---

# go

## slice

### slice如何扩容？

>切片数量小于1024个元素那么扩容的时候slice的cap就翻倍,一旦超过1024个元素增长因子就变成零1.25也就是每次增长原来容量的四分之一.
>
>如果扩容之后还没有触及原来数组的容量,那么切片中的指针指向的位置就还是原数组位置,如果扩容之后超过了原数组的容量,那么go会开辟一块新的内存,把原来的值拷贝过来这种情况丝毫不会影响原数组

## map

### map 的key为什么是无序的？

>map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。

### 不对现有的map做增删改操作为什么遍历时key还是无序的？

>当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key/value 对了。

### 在map遍历的时候对这个map做添加操作每次添加相同数量的key后为什么最后的map size都不一样？

>因为range取map的顺序随机，range会再次遍历刚刚新加入map的键值对。

### map的value存储为结构体该怎么修改值

>直接取出value修改是无效的，修改方式有二：一拿出value修改value然后替换老的value. map[key] = newValue
>
>第二不要直接存储结构体而是存储结构体的指针，这样修改就可以获取指针然后进行修改.  (*map[key]).name = value

## chan

### 无缓冲Chan的发送和接受是否同步？

>ch := make(chan int)    无缓冲的channel由于没有缓冲发送的和接受需要同步
>
>ch := make(chan int,2) 有缓冲channe不要求发送和接受操作同步
>
>1. chanmel无缓冲时，发送阻塞直到数据被接受，接受阻塞直到读到数据
>2. channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接受阻塞

|   操作   | 一个零值nil chan | 一个非零值但已关闭的chan | 一个非零值且尚未关闭的chan |
| :------: | :--------------: | :----------------------: | :------------------------: |
|   关闭   |    产生panic     |        产生panic         |          成功关闭          |
| 发送数据 |     永久阻塞     |        产生panic         |       发送成功或阻塞       |
| 接收数据 |     永久阻塞     |         永不阻塞         |       接收成功或阻塞       |





## Goroutine

### CSP并发模型是什么？

>CSP：通信顺序过程；以通信的方式共享内存。

### Goroutine的特点优点

>1. 用户空间，避免了内核态和用户态的切换导致的成本。
>2. 可以由语言和框架层进行调度
>3. 更小的栈空间允许创建大量实例

### Goroutine的特性

>Golang内部有三个对象,P对象(processor)代表上下文(或者可以认为是cpu);M(work thread)代表工作线程;G(Goroutine)协程.
>
>当cpu对象启动一个工作线程对象,线程去检查并执行goroutine对象,碰到goroutine对象阻塞的时候,会启动一个新的工作线程,以充分利用cpu资源,所有有时候线程对象会比处理器对象多得多

### PMG是什么?

>G:协程,为用户级的轻量级线程,每个goroutine对象中的sched保存着其上下文信息
>
>M:Os内核级线程的封装,数量对应真实的cpu数,是真正执行任务的对象
>
>P:逻辑处理器,即为G和M的调度对象,用来调度G和M之间的关联关系,其数量可通过GOMAXPROSC()来设置,默认为核心数

### PMG如何调度?

>新创建的goroutine会存放到Global全局队列中,等待go调度器进行调度,随后goroutine会被分配给其中一个逻辑调度器P,并放到这个逻辑处理器对应的local本地运行队列中,在M和P绑定后M会不断地从P的队列中取出G执行,当P队列中没有G的时候会从Global全局队列中取,如果全局队列也没有G的话会从其他P的队列中取出G执行(相当于P的负载均衡,一般会拿运行的一半G),如果其他P的队列中也没有G的话这个M就会睡眠(放入线程缓存中),而这个M对应的P则会运行到其他的M中,这个M可能是新创建的也可能是从线程缓存中取出的,当线程缓存中M取出时它必须尝试得到一个P来运行G,一般来说它会从其他的os线程中拿一个P过来运行,如果没有拿到就会把自身的G放到Global全局队列中然后自己睡眠,所有的P也会周期性的检查Global全局队列并运行其中的G.

## other

### go中的CAS是什么?

>CAS算法是原子操作的一种,CAS算法是一种有名的无锁算法,无锁编程即不适用锁的情况下实现多线程之间的变量同步,也就是在没有线程被阻塞的情况下实现变量的同步,所以也叫非阻塞同步,可用于多线程编程中实现不被打断的数据交换操作,从而避免多线程同步改写某一度数据时由于执行顺序不确定以及中断的不可预知性产生的数据不一致问题.
>
>该操作通过将内存中的值与指定数据进行比较,当数值一样时将内存中的数据替换为新的值
>
>Go中CAS操作是借助了CPU提供的原子性指令来实现,CAS操作修改共享变量时不需要对共享变量加锁,而是用过类似乐观锁的方式进行检查,本质还是不断地占用cpu资源换取加锁带来的开销



## Go GC垃圾回收

### 标记清除

>1. 暂定程序业务逻辑,找出可达对象和不可达对象
>2. 把所有可达对象进行标记
>3. 清除所有未标记对象
>4. 停止暂停程序继续运行

#### 缺点

>1. 整个过程需要stw(stop the work),程序会卡顿
>2. 标记需要扫描全部的heap
>3. 清除数据会产生heap碎片

### 标记清除改进

>把标记清除的第三步骤和第四步骤进行调换缩短stw时间

### 三色标记

>1. 起初所有对象均为白色队列
>2. 遍历根对象的直接引用对象,把遍历到的对象从白色队列放到灰色队列
>3. 遍历灰色队列对象的直接引用对象,把遍历的对象放到灰色队列,其本身放到黑色队列,重复此步骤直到灰色队列无对象
>4. 删除在白色队列的对象

#### 缺点

> 如果三色标记过程不被stw保护:
>
> 1. 黑色队列对象引用白色队列A对象
> 2. 灰色队列对象与白色队列A对象的可达关系遭到破坏(取消引用A对象)
>
> 同时满足以上两个条件,这个白色对象就会被当做垃圾进行回收从丢失这个对象

### 强/弱三色不变式

>只要满足强弱三色不变式其一就可以解决三色标记不被stw保护时丢失对象问题

#### 强三色不变式

>黑色队列对象不允许引用白色队列对象

#### 弱三色不变式

>黑色队列的对象可以引用白色队列对象,但是这个白色队列对象要直接或间接的被一个灰色队列对象引用

### 四. 屏障

>屏障就类似于hook钩子函数,在对象的特定状态下触发的一种'函数'
>
>栈内的对象不会触发屏障,避免影响效率
>
>对象插入时触发插入屏障,对象删除时触发删除屏障

#### 插入屏障

>当heap内的黑色队列对象引用一个新的白色对象时,直接把这个白色对象标记为灰色放入灰色队列
>
>当栈内的黑色队列对象引用一个新的白色对象时不触发插入屏障,所以会等到到灰色队列为空准备删除白色对象时触发stw(stw只保护栈空间对象,因为heap空间会触发屏障不会有此问题),再次对栈空间对象进行一次三色标记,然后再删除白色队列对象
>
>插入屏障解决了强三色不变式

#### 缺点

>用了stw,影响整体性能效率

#### 删除屏障

>当heap内的黑色队列对象删除一个白色队列对象时直接把这个白色队列对象标记为灰色放入灰色队列
>
>栈内对象不触发屏障所以删除对象时直接删除即可
>
>删除屏障解决了弱三色不变式

### 五. 混合写屏障

>结合了插入屏障和删除屏障

>1. 栈内的对象初始全部为黑色,不进行第二次扫描
>2. 栈内新引用的对象直接标记为黑色
>3. 新引用的对象标记为灰色
>4. 删除引用的对象标记为灰色

## defer

>当函数中有多个defer其执行顺序为先进后出







# mysql
## mysql有哪些数据类型
> 整型,浮点数,字符串,时间日期

## 什么是事务
>  满足数据库的ACID特性的一组操作,可以通过commit提交事务和rollback回滚

## ACID是什么有哪些
> 1. 原子性: 原子性是指事务是一个不可分割的工作单位,事务的操作具有原子性
> 2. 一致性: 事务必须使数据库从一个一致性状态转变到另一个一致性状态,例如a向b转转,a和b分别有100,无论ab怎么转账最后ab的总额还是200
> 3. 隔离性: 当多个用户访问数据库时同时操作同一个表数据库要为每一个用户开启事务不能被其他事物的操作所干预,保证并发事物之间要隔离
> 4. 持久性: 一旦事务提交,所做的操作必须持久化的保存到数据库中;系统崩溃可以使用备份的数据库进行恢复

## 并发一致性问题
> 1. 丢失修改: a和b事务都已一个数据进行修改,a先修改b随后修改,b会覆盖a的修改
> 2. 脏读数据: 一个事务对数据进行修改但没有提交另一个事物获取到了事务没有提交的数据,这个数据就是脏数据
> 3. 不可重复读: 一个事务多次读取同一数据在这个事务还没有结束时另一个事务也访问了该数据并对数据进行了修改,那么第一个事务读取的多次数据可能不一致; 也就是a事务读取了b事务修改前的数据和修改后的数据
> 4. 幻读: a事务where查询操作,b事务对数据进行修改操作修改后的数据刚好满足a事务的查询条件,导致a事务的查询后的记录数量不同

## 事务隔离级别
> 1. 串行化(最高隔离级别): 强制事务进行排序使其不可能相互冲突,这个级别的事务可能导致大量的超时现象和锁竞争
> 2. 可重复读: 确保统一事务的多个实例在并发读取数据时会看到同样的数据
> 3. 取提交内容: 当前事务只能读取其他事物所提交的数据
> 4. 读未提交内容: 所有事务都可以读取到其他事物没提交数据
> 串行化可以解决全部并发一致性问题
> 可重复读可以解决脏读和不可重复读
> 读未提交内容可以解决脏读
> 读已提交内容最低级别不能解决并发问题 

## 索引是什么
> 索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构

## 索引有哪些
1. 普通索引: 是最基本的索引，它没有任何限制
2. 唯一索引: 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
3. 主键索引: 是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。
4. 组合索引: 指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。
5. 全文索引: 主要用来查找文本中的关键字，而不是直接与索引中的值相比较。

## 索引常用的数据结构
1. 二叉树
    1. 缺点层级太高
2. 红黑树
    1. 红黑树是一种特化的 AVL树（平衡二叉树）都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡；
    2. 缺点:每插入一行记录的同时还要维护红黑树索引字段。
    3. 数据量很大的时候，索引的体积也会很大，可能内存放不下，所以需要从磁盘上进行相关读写，如果树的层级太高，则读写磁盘的次数（I/O交互）就会越多，性能就会越差。
3. hash表
    1. 快速搜索的数据结构，搜索的时间复杂度 O(1)
    2. 缺点:不适用于范围查询。
4. b-树
    1. 自平衡搜索树,每个节点即保存索引有保存数据,搜索过程相当于二分查找
5. b+树
    1. b-树的变种,只有叶子节点保存数据,搜索时相当于二分查找,增加了相邻节点的指向指针
    2. B+树空间利用率更高、可减少I/O次数,磁盘读写代价更低








